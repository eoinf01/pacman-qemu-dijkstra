The firmware comprises numerous files that configure the peripherals, such as the timer and UART serial interfaces and LCD Display, and a few files to handle the main logic of the Pacman game. 

The uart.c file configures the UART peripheral, which allows us to retrieve key entries for use in the main t.c file. The t.c file calls the init method in the uart.c and timer.c, and vid.c to configure the timer peripheral and uarts and frame buffer for the LCD display. The logic checks the VIC and SIC status registers to identify what peripheral is causing the interrupt and calls the correct interrupt handler. 

In the main method of the t.c file, there is a while loop that runs continuously and uses the upeek() to check if there is input available from the UART and gets the key if there is using ugetc(). A switch statement checks if the key is equal to ‘W’,’A’,’S’,’D’ if so, the sprite for Pacman is moved in the correct direction by 16 bits. There a table populated with the values ‘W’, ‘M’, ‘P’ and ‘V’; these values represent power-up, wall, point and an empty 16 x 16 square. Each element in the table is iterated over, and the show_bmp1 function from vid.c is called with the correct bitmap. It is checked if the vertex the Pacman would move into is a wall (‘M’) or not if it is the Pacman isn’t moved and vice versa.

 If it is a valid move, then the move value is set to 1, and it is checked if the place of the Pacman is equal to a point or powerup; if so, the black_point function is called in the vid.c file, which sets the correct pixels in the frame buffer to black and the value in the table is changed to ‘V’ to represent that there is nothing there. When the point Pacman is moving to is a point (‘P’), we increment the score by 1, which calls the function that updates the score char array and prints it to the screen just below the time. When the player collects the power-up (‘W’), his score is multiplied by three. 

All the images are in a bitmap format which allows us to get the individual pixels of the image. The vid.c driver code implements the frame buffer for the LCD Display peripheral and the functions to show the bitmaps at certain x and y position. The putback function is called if the replacePix parameter is set to 1 and value saved in the provided buffer is putback at the correct position in the frame buffer; this prevents the user trails and the ghosts trails. 

The ghost sprites are moved every time the sprite move value is set to 1 which is controlled by the timer drive code in timer.c after the solution path for the each ghost is calculated and the spriteMove value is set back to 0 in the t.c file. The ghost struct consists of its x and y values, a buffer to save the previous positions frame buffer values and it’s current path position for it’s Dijkstra path solution and the length of the path and an array for it’s calculated shortest path.

The Dijkstra.c file which has an implementation of the Dijkstra algorithm is used to compute the shortest path from the starting vector, the ghost’s current vector, and the destination vector, the Pacman current vector, at the time of the function call. The graph, which is passed as a parameter to Dijkstra function, contains all the edges between the vertexes. The graph is populated earlier with edges by looping over each element in the table, converting each point to a vertex, and adding an edge between that vertex and the vertex to the right or down if that vertex is not a wall. The Dijkstra function returns a list of the vertexes which are the shortest path to Pacman, we iterate over this list moving the ghost sprite along these vertexes by converting each vertex to the correct x and y value to pass to the show_bmp() function. When Pacman moves into the same position as a ghost or a ghost moves into Pacman's position, a string to notify the Pacman is dead is printed to the console, and the user is unable to move and the timer_stop() function is called from timer.c 
 
Run the make script (mk file) to run the emulation.